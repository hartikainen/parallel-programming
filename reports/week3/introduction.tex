I implemented the image segmentation (task is1) algorithm and merge sort (task so1) using simple C/C++ code. The benchmarks for the tasks were run on the classroom computer 'drontti'.

The benchmarks for the image segmentation (cp1) are listed on tables \ref{tab:benchmarks/is1-1t.txt}, \ref{tab:benchmarks/is1-2t.txt}, \ref{tab:benchmarks/is1-4t.txt},  \ref{tab:benchmarks/is1-8t.txt}, for 1, 2, 4 and 8 threads respectively. The critical part for the running time is the calclulations done in the innermost for loops. I tried to move all the code that might slow down the execution. There's a weird looking asm(``\#dummy'') line in the loop. That is to control the loop predictions done by the compiler. The number of divisions versus the running times are plotted in the figure \ref{fig:figure/is1-divisions-vs-time}.

For the so1, the code was quite straightforward. I implemented my own merge function, since I didn't notice the existence of std::merge at first. The benchmarks the solution running on 1, 2, 4 and 8 cores can be found from the tables \ref{tab:benchmarks/so1-1t.txt}, \ref{tab:benchmarks/so1-2t.txt}, \ref{tab:benchmarks/so1-4t.txt}, \ref{tab:benchmarks/so1-8t.txt} respectively. Figures \ref{fig:figure/so1-large-random}, \ref{fig:figure/so1-small-random}, \ref{fig:figure/so1-constant}, \ref{fig:figure/so1-increasing} and \ref{fig:figure/so1-decreasing} show the speed up for so1 algorithm versus the input size, for different types of test data.

Best running time for is1 for 400*400 image was 6.453s, and for so1 with 100000000 input size was 2.207s.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "week3.tex"
%%% End:
